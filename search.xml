<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dijkstra算法，分层图最短路</title>
      <link href="/2025/05/12/Dijkstra/"/>
      <url>/2025/05/12/Dijkstra/</url>
      
        <content type="html"><![CDATA[<p>给定一个源点，求解源点到每个点的最短路径长度，单源最短路径算法</p><h4 id="适用范围：有向图，边的权值没有负数"><a href="#适用范围：有向图，边的权值没有负数" class="headerlink" title="适用范围：有向图，边的权值没有负数"></a><strong>适用范围：有向图，边的权值没有负数</strong></h4><h2 id="普通堆实现的Dijkstra算法（最普遍，最常用）"><a href="#普通堆实现的Dijkstra算法（最普遍，最常用）" class="headerlink" title="普通堆实现的Dijkstra算法（最普遍，最常用）:"></a>普通堆实现的Dijkstra算法（最普遍，最常用）:</h2><p>普通堆实现的Dijkstra算法，时间复杂度0(m*log m)，m为边数</p><p>1.distance[i]表示从源点到i点的最短距离，visited[i]表示i节点是否从小根堆弹出过。</p><p>2.准备好小根堆，小根堆存放记录:(x点，源点到x的距离)，小根堆根据距离组织</p><p>3.令distance[源点]&#x3D;0，(源点，0)进入小根堆</p><p>4.从小根堆弹出(u点，源点到u的距离)<br>    a.如果visited[u]&#x3D;&#x3D;true，不做任何处理，重复步骤4</p><p>​b.如果visited[u]&#x3D;&#x3D; false，令visited[u]&#x3D;true，u就算弹出过了然后考察u的每一条边，假设某边去往V，边权为w<br>​1)如果visited[v]&#x3D;&#x3D;false 并且 distance[u]+ w&lt; distance[v令distance[v&#x3D; distance[u]+w,把(v，distance[u]+ w)加入小根堆</p><p>​2)处理完u的每一条边之后，重复步骤4</p><p>5.小根堆为空过程结束，distance表记录了源点到每个节点的最短距离.</p><p><a href="https://ac.nowcoder.com/acm/problem/226492">【模板】单源最短路1 (nowcoder.com)</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">5001</span>],vis[<span class="number">5001</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">5001</span>];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;<span class="comment">//pair.first存储路径长度，pair.second此时到达的点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));<span class="comment">//初始化为最大</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="comment">//如果存在另一个变量的w则需要开一个二维数组来存储，int a[N][N],将两点放在上面，之后在遍历的时候把len+1改成len+a[x][y]即可</span></span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now=pq.<span class="built_in">top</span>().second;</span><br><span class="line">        <span class="type">int</span> len=pq.<span class="built_in">top</span>().first;</span><br><span class="line">        <span class="keyword">if</span>(!vis[now])&#123;</span><br><span class="line">            vis[now]=<span class="number">1</span>;</span><br><span class="line">            dis[now]=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a:g[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a])&#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;len<span class="number">+1</span>,a&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[n])&#123;</span><br><span class="line">        cout&lt;&lt;dis[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想用pair，则可以重载，但是要注意，重载小于号是大根堆，反之是小根堆，如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    <span class="type">int</span> now,val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(P <span class="type">const</span>&amp; it) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;it.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;P&gt; pq;<span class="comment">//这是小根堆</span></span><br></pre></td></tr></table></figure><p>好巧不巧，第二道题就是按照值存储，所以稍作改动就直接ac了</p><p><a href="https://ac.nowcoder.com/acm/problem/226498">【模板】单源最短路2 (nowcoder.com)</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">5001</span>],vis[<span class="number">5001</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">5001</span>];</span><br><span class="line"><span class="type">int</span> l[<span class="number">5001</span>][<span class="number">5001</span>];<span class="comment">//这里是改动</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,w;<span class="comment">//这里是改动</span></span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<span class="comment">//这里是改动</span></span><br><span class="line">        l[x][y]=w;<span class="comment">//这里是改动</span></span><br><span class="line">        l[y][x]=w;<span class="comment">//这里是改动</span></span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now=pq.<span class="built_in">top</span>().second;</span><br><span class="line">        <span class="type">int</span> len=pq.<span class="built_in">top</span>().first;</span><br><span class="line">        <span class="keyword">if</span>(!vis[now])&#123;</span><br><span class="line">            vis[now]=<span class="number">1</span>;</span><br><span class="line">            dis[now]=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a:g[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a])&#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;len+l[a][now],a&#125;);<span class="comment">//这里是改动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[n])&#123;</span><br><span class="line">        cout&lt;&lt;dis[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ac.nowcoder.com/acm/contest/94803/1009">1009-【模板】单源最短路Ⅲ ‖ 非负权图_模板题内测 (nowcoder.com)</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">g</span>(n<span class="number">+1</span>,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,u;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;u;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(&#123;y,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n<span class="number">+1</span>,<span class="number">9e18</span>)</span>,<span class="title">vi</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;</span><br><span class="line">    ans[s]=<span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [val,root] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (val &gt; ans[root]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [son,w]:g[root])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[son]&gt;ans[root]+w)&#123;</span><br><span class="line">                ans[son]=ans[root]+w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;ans[son],son&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==<span class="number">9e18</span>)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
